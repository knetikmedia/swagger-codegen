{{>licenseInfo}}
{{#models}}{{#model}}
#include "{{classname}}.h"

#include "KnetikCloudConstants.h"
#include "KnetikCloudJson.h"
#include "KnetikCloudLogger.h"
#include "KnetikCloudTypeFactory.h"


namespace KnetikCloud
{
	{{classname}}::{{classname}}()
	{
		{{#vars}}
		{{^isInherited}}
		{{#isNotContainer}}
		{{#isPrimitiveType}}
		m{{name}} = {{{defaultValue}}};
		{{/isPrimitiveType}}
		{{^isPrimitiveType}}
		{{#isString}}
		m{{name}} = {{{defaultValue}}};
		{{/isString}}
		{{#isDateTime}}
		m{{name}} = {{{defaultValue}}};
		{{/isDateTime}}
		{{/isPrimitiveType}}
		{{/isNotContainer}}
		{{^required}}
		b{{name}}IsSet = false;
		{{/required}}
		{{/isInherited}}

		{{/vars}}
	}

	{{classname}}::~{{classname}}()
	{
	}

	TSharedPtr<FJsonObject> {{classname}}::ToJson() const
	{
		{{#parent}}
		TSharedPtr<FJsonObject> JsonObject(this->{{{parent}}}::ToJson());
		{{/parent}}
		{{^parent}}
		TSharedPtr<FJsonObject> JsonObject(new FJsonObject());
		{{/parent}}
		{{#vars}}
		{{^isInherited}}
		{{#isListContainer}}

		TArray<TSharedPtr<FJsonValue>> {{name}}JsonValueArray;
		{{name}}JsonValueArray.Reserve(m{{name}}.Num());
		for (auto& CurrentItem : m{{name}})
		{
			TSharedPtr<FJsonValue> ItemJsonValue = KnetikCloudJson::ToJsonValue<>(CurrentItem);
			{{name}}JsonValueArray.Add(ItemJsonValue);
		}

		JsonObject->SetArrayField("{{baseName}}", {{name}}JsonValueArray);
		{{/isListContainer}}
		{{^isListContainer}}
		{{#isMapContainer}}

		TSharedPtr<FJsonObject> {{name}}JsonMap = MakeShareable(new FJsonObject());
		for (auto& KeyValuePair : m{{name}})
		{
			TSharedPtr<FJsonValue> ItemJsonValue = KnetikCloudJson::ToJsonValue<>(KeyValuePair.Value);
			{{name}}JsonMap->Values.Add(KeyValuePair.Key, ItemJsonValue);
		}

		JsonObject->SetObjectField("{{baseName}}", {{name}}JsonMap);
		{{/isMapContainer}}
		{{^isMapContainer}}
	
		KnetikCloudJson::AddToJsonObject<{{{baseType}}}>(JsonObject, "{{baseName}}", m{{name}});
		{{/isMapContainer}}
		{{/isListContainer}}
		{{/isInherited}}
		{{/vars}}
		return JsonObject;
	}

	void {{classname}}::FromJson(TSharedPtr<FJsonObject> JsonObject)
	{
		{{#parent}}
		this->{{{parent}}}::FromJson(JsonObject);
		{{/parent}}
		{{#vars}}
		{{^isInherited}}
		{{#isListContainer}}
		// LIST CONTAINER
		m{{name}}.Empty();
		TArray<TSharedPtr<FJsonValue>> {{name}}JsonValueArray = JsonObject->GetArrayField("{{baseName}}");
		for (auto& ItemJsonValue : {{name}}JsonValueArray)
		{
			{{{items.datatype}}} CurrentItem;
			KnetikCloudJson::FromJsonValue<>(ItemJsonValue, CurrentItem);
			m{{name}}.Add(CurrentItem);
		}
		{{/isListContainer}}
		{{^isListContainer}}
		{{#isMapContainer}}
		// MAP CONTAINER
		m{{name}}.Empty();
		TSharedPtr<FJsonObject> {{name}}JsonObject = JsonObject->GetObjectField("{{baseName}}");
		if ({{name}}JsonObject.IsValid())
		{
			TMap<FString, TSharedPtr<FJsonValue>> {{name}}JsonValuesMap = {{name}}JsonObject->Values;
			for (auto& KeyValuePair : {{name}}JsonValuesMap)
			{
				{{{items.datatype}}} CurrentItem;
				KnetikCloudJson::FromJsonValue<>(KeyValuePair.Value, CurrentItem);
				m{{name}}.Add(KeyValuePair.Key, CurrentItem);
			}
		}
		{{/isMapContainer}}
		{{^isMapContainer}}

		{{{datatype}}} {{name}}Item;
		KnetikCloudJson::GetFromJsonObject<>(JsonObject, "{{baseName}}", {{name}}Item);
		Set{{name}}({{name}}Item);
		{{/isMapContainer}}
		{{/isListContainer}}
		{{/isInherited}}
		{{/vars}}
	}
	{{#vendorExtensions.x-discriminator-value}}

	FString {{classname}}::GetSubtypeString()
	{
		return "{{vendorExtensions.x-discriminator-value}}";
	}
	
	TSharedPtr<{{{parent}}}> {{classname}}::CreateSubtype()
	{
		return TSharedPtr<{{{parent}}}>(new {{classname}}());
	}
	{{/vendorExtensions.x-discriminator-value}}

	{{#vars}}
	{{^isInherited}}
	{{^isNotContainer}}
	{{{datatype}}}& {{classname}}::Get{{name}}()
	{
		return m{{name}};
	}

	void {{classname}}::Set{{name}}(const {{{datatype}}}& Value)
	{
		m{{name}} = Value;
		{{^required}}b{{name}}IsSet = true;{{/required}}
	}

	{{/isNotContainer}}
	{{#isNotContainer}}
	{{{datatype}}} {{classname}}::Get{{name}}() const
	{
		return m{{name}};
	}

	void {{classname}}::Set{{name}}(const {{{datatype}}}& Value)
	{
		m{{name}} = Value;
		{{^required}}b{{name}}IsSet = true;{{/required}}
	}

	{{/isNotContainer}}
	{{^required}}
	bool {{classname}}::{{name}}IsSet() const
	{
		return b{{name}}IsSet;
	}

	void {{classname}}::Unset{{name}}()
	{
		b{{name}}IsSet = false;
	}

	{{/required}}
	{{/isInherited}}
	{{/vars}}
}
{{/model}}
{{/models}}
